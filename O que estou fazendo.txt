-> verificar revistas para submissão

-> buscar empresas de RT para coletar dados sobre número de processos usados

-> pensar sobre limite de processos..

-> ver sobre o thresholds:
-> com um conjunto de processos limitados até N
	-> remoção e inclusão de processos
	-> conjunto dinâmico com N processos
	-> é possível realizar em tempo de execução?
	-> até que ponto é viável?

-> verificar se Buttazzo trabalha com o conjunto de processos estático usando thresholds.

-> implementar equação

-> pensar na aplicação prática da teoria
	- achar uma aproximação para o real da teoria

=========// ============= //

verificar o pior caso de execução onde todos chegam juntos




=========// ============= //

-> Manter por enquanto os mesmos estados para o processo. Criar somente depois para fazer a diferenciação entre um conjunto de processos estático e dinâmicos.

Estático: realizar toda a instanciação de processos através do fork, atribuindo um estado intermediário entre RUNNABLE e RUNNING, que seria um estado sinalizador de 'pronto para ser usado pelo sistema', significaria que o sistema já tem conhecimento da existência do determinado processo e saberá que não havéra mudanças no conjunto de processos no decorrer da execução.

Dinâmico: Os processos serão instanciados através do fork e já estarão aptos para serem executados, logo, se não entrarem em execução, ficarão na fila de pronto com o estado em RUNNABLE.. Assim, uma rotina deverá ser implementada de forma a realizar forks periódicamente durante a execução do sistema. A aplicação poderá mudar a quantidade de processo no conjunto universo durante a execução.

-> Criar funções de manipulação de fila de pronto

-> Modificar fork para receber deadline

-> Criar função para cálcular processo que está perdendo o prazo e ordenar por ordem crescente na fila de pronto.

-> Modificar scheduler para verificar se o primeiro processo na fila de pronto tem um prazo mais curto que o processo que está executando.

-> Pensar em como implemetar o cálculo do tempo. Pensar depois de finalizar o citado.

-> Adicionar relógio global de execução para saber o tempo que passou dada a inicialização do sistema. Fazer a diferença.



Criar chamada de sistema para teste:
Modificar os arquivos:
	- proc.c - - Implementação da função
	- syscall.c - - Comunicação com o assembly
	- sysproc.c -- Implementação da chamada de sistema
	- syscall.h
	- defs.h - - Definição da função
	- user.h - - Definição da chamada de sistema
	- usys.S - - Definição no assembly


	sudo apt-get install g++-multilib libc6-dev-i386

	Manipular a pilha somente
	dentro das travas de proc em ptable para garantir a consitência dos dados do processo


	ok - COMO ACESSAR O REGISTRADOR DE TEMPO?

	IMPLEMENTAR FUNÇÃO DE ORDENAÇÃO


	ok - INSERIR NOVAMENTE O PROCESSO NA FILA DE PRONTO SE ELE AINDA NÃO ACABOU, OU SEJA, EM TODOS OS LUGARES EM QUE O PROCESSO É POSTO COMO RUNNABLE

	MODIFICAR PARÂMETRO DO fork()



	Sobre o TSC:
	- https://www.ccsl.carleton.ca/~jamuir/rdtscpm1.pdf


	ok - ARRUMAR ESTRUTURA DA FILA DE PRONTOS
	


	ok - INSERIR TEMPO DE COMPUTAÇÃO
		MUDAR O FORK ;)

	ok- VERIFICAR ONDE ESTÁ O PROBLEMA DA INICIALIZAÇÃO;

	usar sleep()

	Chamada de sistema para descongelar processos